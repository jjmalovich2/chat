<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Ava and JJ üíñ</title>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
      /* --- CONFIG & DARK MODE --- */
      :root {
        --insta-bg: #000000;
        --insta-gray: #262626;
        --insta-blue: #0095f6;
        --msg-received: #262626;
        --msg-sent: #3797f0;
        --text-main: #f5f5f5;
        --time-text: #8e8e8e;
      }

      body {
        background-color: var(--insta-bg);
        color: var(--text-main);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      .chat-wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: var(--insta-bg);
      }

      /* --- HEADER --- */
      header {
        background: var(--insta-bg);
        border-bottom: 1px solid var(--insta-gray);
        padding: 10px 20px;
        z-index: 10;
      }
      .header-main h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        text-align: center;
        padding-bottom: 10px;
      }

      /* --- PINNED MESSAGES BAR --- */
      #pinnedBar {
        display: none; /* Hidden by default */
        flex-direction: row;
        justify-content: space-between;
        padding: 10px 15px;
        background: #121212;
        border-bottom: 1px solid var(--insta-gray);
        gap: 10px;
      }
      .pin-slot {
        flex: 1;
        background: #262626;
        border-radius: 8px;
        padding: 8px;
        font-size: 12px;
        display: flex;
        flex-direction: column;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .pin-label {
        font-weight: 700;
        color: var(--time-text);
        font-size: 10px;
        margin-bottom: 2px;
        text-transform: uppercase;
      }
      .pin-text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: white;
      }
      .pin-icon {
        position: absolute;
        right: 5px;
        top: 5px;
        font-size: 10px;
        opacity: 0.5;
      }

      /* --- ACTIVE LIST --- */
      #activeList {
        display: flex;
        gap: 15px;
        padding: 5px 0;
        overflow-x: auto;
        scrollbar-width: none;
      }
      #activeList::-webkit-scrollbar {
        display: none;
      }
      .user-status {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        min-width: 60px;
        transition: opacity 0.5s ease;
      }
      .avatar-circle {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        padding: 2px;
        margin-bottom: 4px;
        background: linear-gradient(
          45deg,
          #f09433 0%,
          #e6683c 25%,
          #dc2743 50%,
          #cc2366 75%,
          #bc1888 100%
        );
        position: relative;
      }
      .avatar-inner {
        width: 100%;
        height: 100%;
        background: var(--insta-bg);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 18px;
      }
      .status-dot {
        height: 13px;
        width: 13px;
        background-color: #1ed760;
        border: 2px solid var(--insta-bg);
        border-radius: 50%;
        position: absolute;
        bottom: 22px;
        right: 8px;
        z-index: 2;
      }
      .username-label {
        font-size: 11px;
        max-width: 60px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .user-status.idle {
        opacity: 0.5;
      }
      .user-status.idle .status-dot {
        background-color: #ffcc00;
      }
      .zzz-overlay {
        position: absolute;
        top: -5px;
        right: 0px;
        font-size: 20px;
        animation: floatZ 2s infinite ease-in-out;
        display: none;
        z-index: 10;
        text-shadow: 1px 1px 2px black;
      }
      .user-status.idle .zzz-overlay {
        display: block;
      }
      @keyframes floatZ {
        0% {
          transform: translate(0, 0) scale(0.8);
          opacity: 0.7;
        }
        50% {
          transform: translate(2px, -3px) scale(1.1);
          opacity: 1;
        }
        100% {
          transform: translate(0, 0) scale(0.8);
          opacity: 0.7;
        }
      }

      /* --- MESSAGES --- */
      #messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow-x: hidden;
      }
      .time-separator {
        text-align: center;
        color: var(--time-text);
        font-size: 12px;
        font-weight: 500;
        margin: 20px 0 10px 0;
      }
      .message-row {
        display: flex;
        width: 100%;
        position: relative;
        margin-bottom: 5px;
      }
      .message-row.sent {
        justify-content: flex-end;
      }
      .message-row.received {
        justify-content: flex-start;
      }
      .message {
        padding: 12px 18px;
        border-radius: 22px;
        max-width: 65%;
        font-size: 15px;
        line-height: 1.5;
        word-wrap: break-word;
        position: relative;
        cursor: pointer;
        user-select: none;
        touch-action: pan-y;
        transform: translateX(0);
        will-change: transform;
        display: flex;
        flex-direction: column;
        z-index: 2;
        background-color: var(--msg-received);
        color: white;
      }
      .sent .message {
        border-bottom-right-radius: 4px;
      }
      .received .message {
        border-bottom-left-radius: 4px;
      }
      .message a {
        text-decoration: underline;
        word-break: break-all;
        cursor: pointer;
        color: inherit;
      }

      /* --- CONTEXT MENU (LONG PRESS) --- */
      #contextMenu {
        position: fixed;
        background: #333;
        border-radius: 12px;
        padding: 8px;
        display: none;
        flex-direction: column;
        gap: 5px;
        z-index: 200;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        width: 150px;
      }
      #contextMenu button {
        background: none;
        border: none;
        color: white;
        padding: 10px;
        text-align: left;
        font-size: 16px;
        border-radius: 8px;
        cursor: pointer;
      }
      #contextMenu button:active {
        background: #444;
      }
      #contextOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 199;
        display: none;
      }

      /* --- VISUALS & ANIMATIONS --- */
      .text-content {
        display: inline-block;
        transition: font-size 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        transform-origin: left center;
      }
      .scream {
        font-size: 2.2em;
        font-weight: 800;
        animation: shakeScream 0.8s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      }
      @keyframes shakeScream {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        10% {
          transform: translate(-4px, -4px) rotate(-3deg);
        }
        100% {
          transform: translate(0, 0) rotate(0deg);
        }
      }
      .sender-tag {
        font-size: 11px;
        font-weight: 600;
        margin-bottom: 4px;
        opacity: 0.8;
        margin-left: 10px;
      }
      .chat-image {
        max-width: 100%;
        max-height: 400px;
        object-fit: contain;
        border-radius: 12px;
        margin-top: 5px;
        display: block;
        pointer-events: none;
      }
      .heart-badge {
        position: absolute;
        bottom: -10px;
        background: #262626;
        border: 2px solid #000;
        border-radius: 50%;
        width: 22px;
        height: 22px;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: scale(0);
        transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        z-index: 5;
      }
      .heart-badge.visible {
        transform: scale(1);
      }
      .sent .heart-badge {
        left: -8px;
      }
      .received .heart-badge {
        right: -8px;
      }
      .big-heart-pop {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 40px;
        pointer-events: none;
        opacity: 0;
        z-index: 10;
      }
      .animate-pop {
        animation: popHeart 0.8s ease-out forwards;
      }
      @keyframes popHeart {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.5);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }
      .reply-quote-block {
        background-color: rgba(0, 0, 0, 0.2);
        border-left: 3px solid rgba(255, 255, 255, 0.5);
        padding: 8px 10px;
        border-radius: 8px;
        margin-bottom: 6px;
        font-size: 13px;
        display: flex;
        flex-direction: column;
        pointer-events: none;
      }
      .reply-sender {
        font-weight: 700;
        margin-bottom: 2px;
        opacity: 0.8;
      }
      .reply-text {
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        opacity: 0.8;
      }

      /* --- INPUT --- */
      #replyPreviewBar {
        background-color: #1e1e1e;
        padding: 10px 20px;
        border-top: 1px solid var(--insta-gray);
        display: none;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: #ddd;
      }
      .replying-to-label {
        font-weight: 600;
        color: var(--insta-blue);
        display: block;
        margin-bottom: 2px;
      }
      .input-area {
        padding: 20px;
        border-top: 1px solid var(--insta-gray);
        display: flex;
        align-items: center;
        gap: 10px;
        background: var(--insta-bg);
      }
      .icon-btn {
        background: none;
        border: none;
        color: var(--text-main);
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
      }
      .color-wrapper {
        position: relative;
        width: 30px;
        height: 30px;
        overflow: hidden;
        border-radius: 50%;
        border: 2px solid #555;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      #colorInput {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 50px;
        height: 50px;
        cursor: pointer;
        padding: 0;
        border: none;
        background: none;
      }
      .color-icon {
        font-size: 14px;
        pointer-events: none;
        z-index: 2;
        text-shadow: 0 0 2px black;
      }
      #msgInput {
        flex: 1;
        padding: 14px 24px;
        border: 1px solid var(--insta-gray);
        border-radius: 30px;
        outline: none;
        font-size: 16px;
        background: #262626;
        color: white;
      }
      #sendBtn {
        color: var(--insta-blue);
        background: none;
        border: none;
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
      }

      /* --- CAMERA --- */
      #cameraOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 100;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #cameraVideo {
        width: 100%;
        max-height: 80vh;
        object-fit: cover;
      }
      .camera-controls {
        position: absolute;
        bottom: 30px;
        display: flex;
        gap: 20px;
        align-items: center;
      }
      #snapBtn {
        width: 70px;
        height: 70px;
        background: white;
        border-radius: 50%;
        border: 4px solid #ccc;
        cursor: pointer;
      }
      #closeCameraBtn {
        color: white;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 20px;
      }
      #canvas {
        display: none;
      }

      /* --- TYPING & SEEN --- */
      #typingWrapper {
        display: none;
        flex-direction: column;
        margin-bottom: 10px;
        margin-left: 10px;
      }
      #typingIndicator {
        background-color: var(--msg-received);
        padding: 10px 16px;
        border-radius: 22px;
        border-bottom-left-radius: 4px;
        width: fit-content;
      }
      .typing-dots {
        display: flex;
        align-items: center;
        gap: 4px;
        height: 14px;
      }
      .dot {
        width: 6px;
        height: 6px;
        background-color: #888;
        border-radius: 50%;
        animation: bounce 1.4s infinite ease-in-out both;
      }
      .dot:nth-child(1) {
        animation-delay: -0.32s;
      }
      .dot:nth-child(2) {
        animation-delay: -0.16s;
      }
      @keyframes bounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }
      .typing-label {
        font-size: 10px;
        color: #888;
        margin-bottom: 4px;
        display: block;
      }
      #seenIndicator {
        text-align: right;
        font-size: 11px;
        color: var(--time-text);
        margin-right: 10px;
        margin-bottom: 5px;
        font-weight: 500;
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="chat-wrapper">
      <header>
        <div class="header-main"><h3>Direct üíñ</h3></div>
        <div id="activeList"></div>
      </header>

      <div id="pinnedBar">
        <div class="pin-slot" id="pinSlotMy">
          <span class="pin-label">My Pin üìå</span>
          <span class="pin-text" id="pinTextMy">No message pinned</span>
          <span class="pin-icon">üìå</span>
        </div>
        <div class="pin-slot" id="pinSlotOther">
          <span class="pin-label">Their Pin üìå</span>
          <span class="pin-text" id="pinTextOther">No message pinned</span>
          <span class="pin-icon">üìå</span>
        </div>
      </div>

      <div id="messages"></div>

      <div id="seenIndicator">Seen</div>
      <div id="typingWrapper">
        <div class="typing-label" id="typingLabel">Someone is typing...</div>
        <div id="typingIndicator">
          <div class="typing-dots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
          </div>
        </div>
      </div>

      <div id="replyPreviewBar">
        <div class="reply-info">
          <span class="replying-to-label">Replying...</span>
          <span id="replyPreviewText" style="color: #aaa">Text</span>
        </div>
        <button
          id="cancelReplyBtn"
          style="
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
          "
        >
          &times;
        </button>
      </div>

      <div class="input-area">
        <input type="file" id="fileInput" accept="image/*" hidden />
        <button id="fileBtn" class="icon-btn">üìé</button>
        <button id="cameraBtn" class="icon-btn">üì∑</button>
        <div class="color-wrapper" title="Pick Message Color">
          <span class="color-icon">üé®</span>
          <input type="color" id="colorInput" value="#3797f0" />
        </div>
        <input
          type="text"
          id="msgInput"
          placeholder="Message..."
          autocomplete="off"
        />
        <button id="sendBtn">Send</button>
      </div>
    </div>

    <div id="cameraOverlay">
      <video id="cameraVideo" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      <div class="camera-controls">
        <button id="closeCameraBtn">Cancel</button
        ><button id="snapBtn"></button>
      </div>
    </div>

    <div id="contextOverlay"></div>
    <div id="contextMenu">
      <button id="ctxPin">üìå Pin This</button>
      <button id="ctxDelete">üóëÔ∏è Delete</button>
      <button id="ctxCopy">üìã Copy Text</button>
    </div>

    <script>
      const SUPABASE_URL = "https://xyvyocpdekeewoyvomuv.supabase.co";
      const SUPABASE_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5dnlvY3BkZWtlZXdveXZvbXV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAxNjc0NTEsImV4cCI6MjA4NTc0MzQ1MX0.8VkWO7vxdm4GrMp2FCeF4Ds7sxUVWo1AxOrxbeu4f4Y";
      const { createClient } = supabase;
      const _supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

      let currentReplyData = null;
      let lastMessageTime = null;
      let cameraStream = null;
      let typingTimeout = null;
      let isTyping = false;
      let lastSentMessageTime = null;
      let myName = "";
      let userTimestamps = {};

      // Store loaded messages to find pinned ones easily
      let localMessages = [];
      let selectedMsgId = null; // For context menu

      window.addEventListener("DOMContentLoaded", () => {
        myName = localStorage.getItem("chat-user");
        if (!myName) {
          myName = prompt("Enter your name for the chat:") || "Guest";
          localStorage.setItem("chat-user", myName);
        }

        const savedColor = localStorage.getItem("chat-color") || "#3797f0";
        const colorInput = document.getElementById("colorInput");
        colorInput.value = savedColor;
        colorInput.addEventListener("change", (e) =>
          localStorage.setItem("chat-color", e.target.value)
        );

        const msgInput = document.getElementById("msgInput");
        const sendBtn = document.getElementById("sendBtn");
        const msgDiv = document.getElementById("messages");
        const activeListDiv = document.getElementById("activeList");
        const replyPreviewBar = document.getElementById("replyPreviewBar");
        const fileInput = document.getElementById("fileInput");
        const fileBtn = document.getElementById("fileBtn");
        const cameraBtn = document.getElementById("cameraBtn");

        // Pinned elements
        const pinnedBar = document.getElementById("pinnedBar");
        const pinSlotMy = document.getElementById("pinSlotMy");
        const pinTextMy = document.getElementById("pinTextMy");
        const pinSlotOther = document.getElementById("pinSlotOther");
        const pinTextOther = document.getElementById("pinTextOther");

        // Context Menu elements
        const contextMenu = document.getElementById("contextMenu");
        const contextOverlay = document.getElementById("contextOverlay");
        const ctxPin = document.getElementById("ctxPin");
        const ctxDelete = document.getElementById("ctxDelete");
        const ctxCopy = document.getElementById("ctxCopy");

        const typingWrapper = document.getElementById("typingWrapper");
        const typingLabel = document.getElementById("typingLabel");
        const seenIndicator = document.getElementById("seenIndicator");
        msgDiv.appendChild(seenIndicator);
        msgDiv.appendChild(typingWrapper);

        const cameraOverlay = document.getElementById("cameraOverlay");
        const cameraVideo = document.getElementById("cameraVideo");
        const snapBtn = document.getElementById("snapBtn");
        const closeCameraBtn = document.getElementById("closeCameraBtn");
        const canvas = document.getElementById("canvas");

        function getComplementaryColor(hex) {
          hex = hex.replace("#", "");
          let r = parseInt(hex.substring(0, 2), 16);
          let g = parseInt(hex.substring(2, 4), 16);
          let b = parseInt(hex.substring(4, 6), 16);
          r = (255 - r).toString(16).padStart(2, "0");
          g = (255 - g).toString(16).padStart(2, "0");
          b = (255 - b).toString(16).padStart(2, "0");
          return `#${r}${g}${b}`;
        }
        function formatTime(dateObj) {
          return dateObj.toLocaleTimeString([], {
            weekday: "short",
            hour: "numeric",
            minute: "2-digit",
          });
        }
        function linkify(text) {
          if (!text) return "";
          const urlPattern =
            /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
          return text.replace(
            urlPattern,
            '<a href="$1" target="_blank">$1</a>'
          );
        }

        async function updateMySeenStatus() {
          try {
            await _supabase
              .from("user_presence")
              .upsert({
                username: myName,
                last_seen: new Date().toISOString(),
              });
          } catch (e) {}
        }

        function checkStatusLoop() {
          // Just refresh active list visually, timestamp logic handled in fetch
          renderActiveList();
        }
        setInterval(checkStatusLoop, 5000);
        msgInput.addEventListener("focus", updateMySeenStatus);
        window.addEventListener("click", updateMySeenStatus);

        function renderActiveList() {
          const state = presenceChannel.presenceState();
          const onlineUsers = Object.keys(state);
          if (onlineUsers.length === 0) {
            activeListDiv.innerHTML = "";
            return;
          }
          const now = new Date();
          activeListDiv.innerHTML = onlineUsers
            .map((name) => {
              const initial = name.charAt(0).toUpperCase();
              let isIdle = false;
              if (userTimestamps[name]) {
                if ((now - userTimestamps[name]) / 1000 / 60 > 3) isIdle = true;
              }
              const idleClass = isIdle ? "idle" : "";
              return `<div class="user-status ${idleClass}"><div class="avatar-circle"><div class="avatar-inner">${initial}</div></div><div class="zzz-overlay">üí§</div><span class="status-dot"></span><span class="username-label">${
                name === myName ? "You" : name
              }</span></div>`;
            })
            .join("");
        }

        // --- UPDATE PINNED HEADER ---
        function updatePinnedHeader() {
          // Find latest pinned for ME and THEM
          const myPinned = localMessages
            .slice()
            .reverse()
            .find((m) => m.sender === myName && m.is_pinned);
          const otherPinned = localMessages
            .slice()
            .reverse()
            .find((m) => m.sender !== myName && m.is_pinned);

          if (myPinned || otherPinned) pinnedBar.style.display = "flex";
          else pinnedBar.style.display = "none";

          if (myPinned) {
            pinTextMy.innerText = myPinned.content || "Image";
            pinSlotMy.onclick = () =>
              document
                .getElementById(`msg-${myPinned.id}`)
                .scrollIntoView({ behavior: "smooth", block: "center" });
          } else {
            pinTextMy.innerText = "Nothing pinned";
          }

          if (otherPinned) {
            pinTextOther.innerText = otherPinned.content || "Image";
            document.querySelector(
              "#pinSlotOther .pin-label"
            ).innerText = `${otherPinned.sender}'s Pin üìå`;
            pinSlotOther.onclick = () =>
              document
                .getElementById(`msg-${otherPinned.id}`)
                .scrollIntoView({ behavior: "smooth", block: "center" });
          } else {
            pinTextOther.innerText = "Nothing pinned";
          }
        }

        function renderMessage(data) {
          // Add to local cache or update it
          const existingIndex = localMessages.findIndex(
            (m) => m.id === data.id
          );
          if (existingIndex >= 0) localMessages[existingIndex] = data;
          else localMessages.push(data);

          // Update header whenever a message renders/updates
          updatePinnedHeader();

          const msgId = data.id;
          let rowDiv = document.getElementById(`msg-${msgId}`);
          let div;

          if (rowDiv) {
            div = rowDiv.querySelector(".message");
            div.savedLikes = data.liked_by || [];
            updateLikeVisuals(div, div.savedLikes);
            // Re-apply content in case pinned status changed visuals (optional)
            return;
          }

          typingWrapper.style.display = "none";
          const currentMsgTime = new Date(data.created_at);
          if (
            !lastMessageTime ||
            currentMsgTime - lastMessageTime > 5 * 60 * 1000
          ) {
            const timeDiv = document.createElement("div");
            timeDiv.className = "time-separator";
            timeDiv.innerText = formatTime(currentMsgTime);
            msgDiv.insertBefore(timeDiv, seenIndicator);
            lastMessageTime = currentMsgTime;
          }

          const isMe = data.sender === myName;
          if (isMe) {
            lastSentMessageTime = data.created_at;
            seenIndicator.style.display = "none";
          } else {
            updateMySeenStatus();
          }

          rowDiv = document.createElement("div");
          rowDiv.className = `message-row ${isMe ? "sent" : "received"}`;
          rowDiv.id = `msg-${msgId}`;

          div = document.createElement("div");
          div.className = "message";
          div.savedLikes = data.liked_by || [];

          if (data.user_color) {
            div.style.backgroundColor = data.user_color;
            div.style.color = getComplementaryColor(data.user_color);
          } else {
            if (isMe) div.style.backgroundColor = "var(--msg-sent)";
            else div.style.backgroundColor = "var(--msg-received)";
          }

          // --- LONG PRESS MENU LOGIC ---
          let pressTimer;
          div.addEventListener(
            "touchstart",
            (e) => {
              pressTimer = setTimeout(() => {
                showContextMenu(
                  e.touches[0].clientX,
                  e.touches[0].clientY,
                  data,
                  isMe
                );
              }, 600);
            },
            { passive: true }
          );
          div.addEventListener("touchend", () => clearTimeout(pressTimer));
          div.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showContextMenu(e.clientX, e.clientY, data, isMe);
          });

          // Double tap to like
          let lastTap = 0;
          div.addEventListener("touchend", (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0) {
              e.preventDefault();
              handleLikeToggle(div, msgId);
            }
            lastTap = currentTime;
          });
          div.addEventListener("dblclick", (e) => {
            e.preventDefault();
            handleLikeToggle(div, msgId);
          });

          // Swipe to reply
          let startX = 0;
          let currentTranslate = 0;
          let isDragging = false;
          const startDrag = (clientX) => {
            startX = clientX;
            isDragging = true;
            div.style.transition = "none";
          };
          const moveDrag = (clientX, e) => {
            if (!isDragging) return;
            const diff = clientX - startX;
            if (diff > 0 && diff < 100) {
              if (e && diff > 5) e.preventDefault();
              currentTranslate = diff;
              div.style.transform = `translateX(${diff}px)`;
            }
          };
          const endDrag = () => {
            if (!isDragging) return;
            isDragging = false;
            div.style.transition =
              "transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)";
            div.style.transform = "translateX(0px)";
            if (currentTranslate > 50)
              initiateReply(
                data.message_type === "image" ? "üì∑ Image" : data.content,
                data.sender
              );
            currentTranslate = 0;
          };
          div.addEventListener(
            "touchstart",
            (e) => startDrag(e.touches[0].clientX),
            { passive: true }
          );
          div.addEventListener(
            "touchmove",
            (e) => moveDrag(e.touches[0].clientX, e),
            { passive: false }
          );
          div.addEventListener("touchend", endDrag);

          let replyBlock = "";
          if (data.reply_to) {
            const rSender =
              data.reply_to.sender === myName ? "You" : data.reply_to.sender;
            replyBlock = `<div class="reply-quote-block"><span class="reply-sender">${rSender}</span><span class="reply-text">${data.reply_to.text}</span></div>`;
          }

          let contentHtml = "";
          let isScreaming = false;
          if (data.message_type === "image")
            contentHtml = `<img src="${data.image_url}" class="chat-image" loading="lazy" />`;
          else {
            const text = data.content || "";
            isScreaming = /[a-zA-Z]/.test(text) && text === text.toUpperCase();
            contentHtml = `<div class="text-content">${linkify(text)}</div>`;
          }

          let nameLabel = !isMe
            ? `<span class="sender-tag">${data.sender}</span>`
            : "";
          const heartBadge = document.createElement("div");
          heartBadge.className = "heart-badge";
          heartBadge.innerText = "‚ù§Ô∏è";

          div.innerHTML = `${nameLabel} ${replyBlock} ${contentHtml}`;
          div.appendChild(heartBadge);

          if (isScreaming) {
            const textDiv = div.querySelector(".text-content");
            if (textDiv) {
              setTimeout(() => {
                textDiv.classList.add("scream");
              }, 10);
            }
          }
          updateLikeVisuals(div, div.savedLikes);
          rowDiv.appendChild(div);
          msgDiv.insertBefore(rowDiv, seenIndicator);
          msgDiv.scrollTop = msgDiv.scrollHeight;
        }

        // --- CONTEXT MENU FUNCTIONS ---
        function showContextMenu(x, y, msgData, isMe) {
          selectedMsgId = msgData.id;

          // Adjust buttons based on who sent it
          ctxDelete.style.display = isMe ? "block" : "none";
          ctxPin.innerText = msgData.is_pinned
            ? "üö´ Unpin Message"
            : "üìå Pin Message";

          contextMenu.style.display = "flex";
          contextOverlay.style.display = "block";

          // Positioning logic to keep in bounds
          let posX = x + 10;
          let posY = y + 10;
          if (posX + 150 > window.innerWidth) posX = window.innerWidth - 160;
          if (posY + 120 > window.innerHeight) posY = window.innerHeight - 130;

          contextMenu.style.left = posX + "px";
          contextMenu.style.top = posY + "px";
        }

        function hideContextMenu() {
          contextMenu.style.display = "none";
          contextOverlay.style.display = "none";
          selectedMsgId = null;
        }
        contextOverlay.onclick = hideContextMenu;

        ctxCopy.onclick = () => {
          const msg = localMessages.find((m) => m.id === selectedMsgId);
          if (msg && msg.content) navigator.clipboard.writeText(msg.content);
          hideContextMenu();
        };

        ctxDelete.onclick = async () => {
          if (!confirm("Delete this message?")) return;
          await _supabase.from("messages").delete().eq("id", selectedMsgId);
          hideContextMenu();
        };

        ctxPin.onclick = async () => {
          const msg = localMessages.find((m) => m.id === selectedMsgId);
          if (!msg) return;
          // Toggle pin status
          await _supabase
            .from("messages")
            .update({ is_pinned: !msg.is_pinned })
            .eq("id", selectedMsgId);
          hideContextMenu();
        };

        function updateLikeVisuals(messageDiv, likedBy) {
          const badge = messageDiv.querySelector(".heart-badge");
          if (likedBy.length > 0) badge.classList.add("visible");
          else badge.classList.remove("visible");
        }

        async function handleLikeToggle(div, msgId) {
          const isUnliking = div.savedLikes.includes(myName);
          const newLikedBy = isUnliking
            ? div.savedLikes.filter((name) => name !== myName)
            : [...div.savedLikes, myName];
          await _supabase
            .from("messages")
            .update({ liked_by: newLikedBy })
            .eq("id", msgId);

          if (isUnliking) {
            // Nothing specific for unlike animation in this version, keep it simple
          } else {
            const pop = document.createElement("div");
            pop.className = "big-heart-pop animate-pop";
            pop.innerText = "‚ù§Ô∏è";
            div.appendChild(pop);
            setTimeout(() => pop.remove(), 1000);
          }
        }

        function initiateReply(text, sender) {
          currentReplyData = { text: text, sender: sender };
          document.querySelector(
            ".replying-to-label"
          ).innerText = `Replying to ${sender}`;
          document.getElementById("replyPreviewText").innerText = text;
          replyPreviewBar.style.display = "flex";
          msgInput.focus();
        }
        document.getElementById("cancelReplyBtn").onclick = () => {
          currentReplyData = null;
          replyPreviewBar.style.display = "none";
        };

        msgInput.addEventListener("input", () => {
          clearTimeout(typingTimeout);
          if (!isTyping) {
            isTyping = true;
            roomChannel.send({
              type: "broadcast",
              event: "typing",
              payload: { sender: myName, isTyping: true },
            });
          }
          typingTimeout = setTimeout(() => {
            isTyping = false;
            roomChannel.send({
              type: "broadcast",
              event: "typing",
              payload: { sender: myName, isTyping: false },
            });
          }, 2000);
        });

        async function uploadAndSendImage(fileBlob) {
          if (!fileBlob) return;
          msgInput.placeholder = "Uploading...";
          fileBtn.disabled = true;
          cameraBtn.disabled = true;
          const myColor = document.getElementById("colorInput").value;
          const fileName = `${Date.now()}_captured.jpg`;
          const { error } = await _supabase.storage
            .from("chat-images")
            .upload(fileName, fileBlob, { contentType: "image/jpeg" });
          if (!error) {
            const { data: urlData } = _supabase.storage
              .from("chat-images")
              .getPublicUrl(fileName);
            await _supabase.from("messages").insert([
              {
                sender: myName,
                message_type: "image",
                image_url: urlData.publicUrl,
                content: "üì∑ Image",
                reply_to: currentReplyData,
                user_color: myColor,
              },
            ]);
          }
          msgInput.placeholder = "Message...";
          fileBtn.disabled = false;
          cameraBtn.disabled = false;
          fileInput.value = "";
          if (currentReplyData)
            document.getElementById("cancelReplyBtn").click();
        }
        fileBtn.onclick = () => fileInput.click();
        fileInput.onchange = (e) => uploadAndSendImage(e.target.files[0]);

        // Camera Logic
        async function startCamera() {
          try {
            cameraStream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
              audio: false,
            });
            cameraVideo.srcObject = cameraStream;
            cameraOverlay.style.display = "flex";
          } catch (err) {
            alert("Camera access denied.");
          }
        }
        function stopCamera() {
          if (cameraStream)
            cameraStream.getTracks().forEach((track) => track.stop());
          cameraVideo.srcObject = null;
          cameraOverlay.style.display = "none";
        }
        function takePicture() {
          canvas.width = cameraVideo.videoWidth;
          canvas.height = cameraVideo.videoHeight;
          canvas
            .getContext("2d")
            .drawImage(cameraVideo, 0, 0, canvas.width, canvas.height);
          canvas.toBlob(
            (blob) => {
              stopCamera();
              uploadAndSendImage(blob);
            },
            "image/jpeg",
            0.8
          );
        }
        cameraBtn.onclick = startCamera;
        closeCameraBtn.onclick = stopCamera;
        snapBtn.onclick = takePicture;

        async function fetchHistory() {
          const { data, error } = await _supabase
            .from("messages")
            .select("*")
            .order("created_at", { ascending: true });
          if (!error) {
            const children = Array.from(msgDiv.children);
            children.forEach((child) => {
              if (child.id !== "seenIndicator" && child.id !== "typingWrapper")
                msgDiv.removeChild(child);
            });
            lastMessageTime = null;
            localMessages = [];
            data.forEach(renderMessage);
            checkStatusLoop();
            updateMySeenStatus();
          }
        }

        async function sendMessage() {
          const content = msgInput.value.trim();
          if (!content) return;
          msgInput.value = "";
          clearTimeout(typingTimeout);
          isTyping = false;
          roomChannel.send({
            type: "broadcast",
            event: "typing",
            payload: { sender: myName, isTyping: false },
          });
          const myColor = document.getElementById("colorInput").value;
          await _supabase
            .from("messages")
            .insert([
              {
                content: content,
                sender: myName,
                message_type: "text",
                reply_to: currentReplyData,
                user_color: myColor,
              },
            ]);
          if (currentReplyData)
            document.getElementById("cancelReplyBtn").click();
        }

        const presenceChannel = _supabase.channel("online-users", {
          config: { presence: { key: myName } },
        });
        presenceChannel
          .on("presence", { event: "sync" }, () => {
            renderActiveList();
          })
          .subscribe(async (status) => {
            if (status === "SUBSCRIBED")
              await presenceChannel.track({
                online_at: new Date().toISOString(),
              });
          });

        const roomChannel = _supabase
          .channel("chat-room")
          .on(
            "postgres_changes",
            { event: "INSERT", schema: "public", table: "messages" },
            (payload) => renderMessage(payload.new)
          )
          .on(
            "postgres_changes",
            { event: "UPDATE", schema: "public", table: "messages" },
            (payload) => renderMessage(payload.new)
          )
          .on(
            "postgres_changes",
            { event: "DELETE", schema: "public", table: "messages" },
            (payload) => {
              const el = document.getElementById(`msg-${payload.old.id}`);
              // Remove from local cache
              localMessages = localMessages.filter(
                (m) => m.id !== payload.old.id
              );
              updatePinnedHeader();
              if (el) el.remove();
            }
          )
          .on(
            "postgres_changes",
            { event: "*", schema: "public", table: "user_presence" },
            () => checkStatusLoop()
          )
          .on("broadcast", { event: "typing" }, (payload) => {
            if (payload.payload.sender !== myName) {
              if (payload.payload.isTyping) {
                typingWrapper.style.display = "flex";
                typingLabel.innerText = `${payload.payload.sender} is typing...`;
                msgDiv.scrollTop = msgDiv.scrollHeight;
              } else {
                typingWrapper.style.display = "none";
              }
            }
          })
          .subscribe();

        sendBtn.onclick = sendMessage;
        msgInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") sendMessage();
        });
        fetchHistory();
      });
    </script>
  </body>
</html>
